import React, { useState, useEffect, useRef, useCallback } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { useNavigate, useParams } from 'react-router-dom';
import { TbEdit, TbPlus, TbLoader } from 'react-icons/tb';
import { motion, AnimatePresence } from 'framer-motion';
import { usePersonaBuilder, useAutoGeneratePersonas, useUpdatePersona, personaKeys } from '../../../../../../../hooks/usePersonaBuilder';
import { useUpdateExplorationMethod, useExploration } from '../../../../../../../hooks/useExplorations';
import { useTheme } from '../../../../../../../context/ThemeContext';
import { useOmniWorkflow } from '../../../../../../../hooks/useOmiWorkflow';
import { optionData, contentData, traitGroupMapping, traitNameMapping, multiSelectAttributes } from './data';

// Components
import Header from './components/Header';
import TabsNavigation from './components/TabsNavigation';
import EmptyState from './components/EmptyState';
import PersonaListItem from './components/PersonaListItem';
import BackstoryModal from './components/BackstoryModal';
import ValidationModal from './components/ValidationModal';
import ApproachSelectionModal from './components/ApproachSelectionModal';
import AttributeItem from './components/AttributeItem';
import SelectionPanel from './components/SelectionPanel';

const PersonaBuilder = () => {
  const queryClient = useQueryClient();
  const navigate = useNavigate();
  const { workspaceId, objectiveId } = useParams();
  const { theme } = useTheme();

  const {
    personas: fetchedPersonas,
    createPersona,
    isCreating,
    submitCompletePersona,
    isSubmitting,
    validateTraits,
    isValidating,
    validationResult
  } = usePersonaBuilder(workspaceId, objectiveId);

  const {
    data: autoGeneratedData,
    isLoading: isGeneratingPersonas,
    refetch: generatePersonas,
    isError: isGenerationError,
    error: generationError,
    remove: removeAutoGeneratedData
  } = useAutoGeneratePersonas(workspaceId, objectiveId, {
    enabled: false,
  });

  const savedPersonasFromAPI = Array.isArray(fetchedPersonas) ? fetchedPersonas : (fetchedPersonas?.data || []);

  // Create a map of persona IDs to persona objects for easy lookup
  const personaMap = useRef({});
  useEffect(() => {
    personaMap.current = savedPersonasFromAPI.reduce((map, persona) => {
      if (persona.id) {
        map[persona.id] = persona;
      }
      return map;
    }, {});
  }, [savedPersonasFromAPI]);

  useEffect(() => {
    if (objectiveId) {
      trigger({
        stage: 'persona_builder',
        event: 'PERSONA_WORKFLOW_LOADED',
        payload: {},
      });
    }
  }, [objectiveId]);

  const tabs = ["Persona", ...Object.keys(contentData).filter(tab => tab !== "Persona")];
  const [activeTab, setActiveTab] = useState("Demographics");
  const [isTraitLoading, setIsTraitLoading] = useState(false);


  const { trigger } = useOmniWorkflow();
  const [editingPersonaId, setEditingPersonaId] = useState(null);
  const [newPersonaName, setNewPersonaName] = useState("");
  const [isNewPersona, setIsNewPersona] = useState(false);
  const [showBackstoryPopup, setShowBackstoryPopup] = useState(false);
  const [backstory, setBackstory] = useState("");
  const [pendingAction, setPendingAction] = useState(null);
  const [pendingPersonaData, setPendingPersonaData] = useState(null);

  // Store persona IDs instead of names
  const [personaIds, setPersonaIds] = useState([]);
  const [selectedPersonaId, setSelectedPersonaId] = useState(null);

  // Store persona data keyed by ID
  const [personaDataById, setPersonaDataById] = useState({});

  const [editingItem, setEditingItem] = useState(null);
  const [validationError, setValidationError] = useState(null);
  const [showValidationModal, setShowValidationModal] = useState(false);
  const [showApproachModal, setShowApproachModal] = useState(false);
  const [isNavigatingToPreview, setIsNavigatingToPreview] = useState(false);
  const [isMockGenerating, setIsMockGenerating] = useState(false);

  // Add a ref to track processed personas to prevent infinite loops
  const processedPersonaRef = useRef(new Set());
  const hasInitializedRef = useRef(false);

  // Initialize useUpdatePersona hook
  const updatePersonaMutation = useUpdatePersona(workspaceId, objectiveId, selectedPersonaId);
  const isUpdating = updatePersonaMutation.isPending;

  const updateExplorationMethodMutation = useUpdateExplorationMethod();
  const { data: explorationData } = useExploration(objectiveId);

  // Resilient derivation of exploration properties
  const exploration = explorationData?.data || explorationData;
  const currentApproach = exploration?.research_approach;
  const isApproachLocked = !!(exploration?.is_qualitative || exploration?.is_quantitative);

  // Helper function to format saved persona data
  const formatPersonaData = useCallback((persona) => {
    const details = persona.persona_details || {};

    console.log("DEBUG formatPersonaData - Received from backend:", {
      personaId: persona.id,
      decision_making_style: persona.decision_making_style,
      decision_making_style_1: persona.decision_making_style_1,
      purchase_frequency: persona.purchase_frequency,
      purchase_channel: persona.purchase_channel,
      hasPersonaDetails: !!persona.persona_details,
      fullPersona: persona
    });

    return {
      name: persona.name || details.name || "Unnamed Persona",
      "Age": persona.age_range || details.age_range || "",
      "Gender": persona.gender || details.gender || "",
      "Geography": persona.geography || persona.location_country || persona.location_state || details.geography || details.location_country || "",
      "Education Level": persona.education_level || details.education_level || "",
      "Occupation / Employment Type": persona.occupation || details.occupation || "",
      "Income Level": persona.income_range || details.income_range || "",
      "backstory": persona.backstory || details.backstory || "",
      "id": persona.id,
      "Family Structure": persona.family_size || details.family_size || "",
      "Lifestyle": persona.lifestyle || details.lifestyle || "",
      "Hobbies": persona.hobbies || details.hobbies || "",
      "Marital Status": persona.marital_status || details.marital_status || "",
      "Daily Rhythm": persona.daily_rhythm || details.daily_rhythm || "",
      "Values": persona.values || details.values || "",
      "Personality": persona.personality || details.personality || "",
      "Interests": persona.interests || details.interests || "",
      "Motivations": persona.motivations || details.motivations || "",
      "Brand Sensitivity": persona.brand_sensitivity || persona.brand_sensitivity_detailed || details.brand_sensitivity || details.brand_sensitivity_detailed || "",
      "Price Sensitivity": persona.price_sensitivity || persona.price_sensitivity_general || details.price_sensitivity || details.price_sensitivity_general || "",
      "Preferences": persona.preferences || details.preferences || "",
      "Digital Activity": persona.digital_activity || details.digital_activity || "",
      "Professional Traits": persona.professional_traits || details.professional_traits || "",
      "Mobility": persona.mobility || details.mobility || "",
      "Home Ownership": persona.accommodation || details.accommodation || "",
      // Behavioral Traits
      "Decision Making Style": persona.decision_making_style || persona.decision_making_style_1 || details.decision_making_style || details.decision_making_style_1 || "",
      "Purchase Frequency": persona.purchase_frequency || details.purchase_frequency || "",
      "Purchase Channel": persona.purchase_channel || persona.purchase_channel_detailed || details.purchase_channel || details.purchase_channel_detailed || "",
      "Price Sensitivity Profile": persona.price_sensitivity_profile || details.price_sensitivity_profile || "",
      "Loyalty / Switching Behavior": persona.loyalty_behavior || details.loyalty_behavior || "",
      "Purchase Triggers & Occasions": persona.purchase_triggers || details.purchase_triggers || "",
      "Purchase Barriers": persona.purchase_barriers || details.purchase_barriers || "",
      "Decision-Making Style": persona.decision_making_style_2 || details.decision_making_style_2 || "",
      "Media Consumption Patterns": persona.media_consumption || details.media_consumption || "",
      "Digital Behavior": persona.digital_behavior || persona.digital_behavior_detailed || details.digital_behavior || details.digital_behavior_detailed || "",
      "Purchase patterns": persona.purchase_patterns || details.purchase_patterns || "",
      "Purchase channel": persona.purchase_channel || details.purchase_channel || "",
      "isAI": persona.auto_generated_persona || false,
      "isAIGenerated": persona.auto_generated_persona || false,
      "isSaved": true
    };
  }, []);

  // Initialize from saved personas - run only once when savedPersonasFromAPI changes
  useEffect(() => {
    if (savedPersonasFromAPI?.length > 0 && !hasInitializedRef.current) {
      console.log("Initializing from saved personas:", savedPersonasFromAPI.length);

      const ids = savedPersonasFromAPI.map(p => p.id).filter(id => id);

      // Initialize persona data
      const initialPersonaData = {};
      savedPersonasFromAPI.forEach(p => {
        if (p.id && !initialPersonaData[p.id]) {
          initialPersonaData[p.id] = formatPersonaData(p);
        }
      });

      setPersonaIds(ids);
      setPersonaDataById(initialPersonaData);

      // Select first persona if none selected
      if (!selectedPersonaId && ids.length > 0) {
        setSelectedPersonaId(ids[0]);
      }

      hasInitializedRef.current = true;
    } else if (savedPersonasFromAPI?.length === 0) {
      // Reset if no personas
      hasInitializedRef.current = false;
    }
  }, [savedPersonasFromAPI, formatPersonaData, selectedPersonaId]);

  // Effect to handle auto-generated personas when they arrive
  useEffect(() => {
    if (autoGeneratedData?.data?.consumer_personas && autoGeneratedData.data.consumer_personas.length > 0) {
      const generatedPersonas = autoGeneratedData.data.consumer_personas;

      // Check if we've already processed this exact data
      const dataSignature = JSON.stringify(generatedPersonas.map(p => p.name));
      if (processedPersonaRef.current.has(dataSignature)) {
        console.log("Already processed these personas, skipping...");
        return;
      }

      console.log("Generated Personas:", generatedPersonas);

      const newPersonaData = {};
      const newPersonaIds = [];

      generatedPersonas.forEach((persona, index) => {
        // Generate a unique ID for the persona
        const personaId = `ai-generated-${Date.now()}-${index}`;

        // Check if persona already exists in current state
        const personaKey = `${persona.name}-${persona.age_range}`;
        if (processedPersonaRef.current.has(personaKey)) {
          console.log(`Persona ${persona.name} already exists, skipping`);
          return;
        }

        // Check if this persona already exists in saved personas
        const isAlreadySaved = savedPersonasFromAPI.some(savedPersona =>
          savedPersona.name === persona.name &&
          savedPersona.age_range === persona.age_range
        );

        if (isAlreadySaved) {
          console.log(`Persona ${persona.name} already saved in database, skipping`);
          return;
        }

        newPersonaIds.push(personaId);
        processedPersonaRef.current.add(personaKey);

        newPersonaData[personaId] = {
          name: persona.name || "AI Persona",
          "Age": persona.age_range || "",
          "Gender": persona.gender || "",
          "Geography": persona.geography || persona.location_country || persona.location_state || "",
          "Education Level": persona.education_level || "",
          "Occupation / Employment Type": persona.occupation || "",
          "Income Level": persona.income_range || "",
          "backstory": persona.backstory || "",
          "id": personaId,
          "Family Structure": persona.family_size || "",
          "Lifestyle": persona.lifestyle || "",
          "Hobbies": persona.hobbies || "",
          "Marital Status": persona.marital_status || "",
          "Daily Rhythm": persona.daily_rhythm || "",
          "Values": persona.values || "",
          "Personality": persona.personality || "",
          "Interests": persona.interests || "",
          "Motivations": persona.motivations || "",
          "Brand sensitivity": persona.brand_sensitivity || "",
          "Price sensitivity": persona.price_sensitivity || "",
          "Decision Making Style": persona.decision_making_style || "",
          "Purchase patterns": persona.purchase_patterns || "",
          "Purchase channel": persona.purchase_channel || "",
          "Preferences": persona.preferences || "",
          "Digital Activity": persona.digital_activity || "",
          "Professional Traits": persona.professional_traits || "",
          "Mobility": persona.mobility || "",
          "Home Ownership": persona.accommodation || "",
          "isAI": true,
          "isAIGenerated": true,
          "isSaved": false,
          originalData: persona
        };

        console.log(`Adding new AI persona: ${persona.name} with ID: ${personaId}`);
      });

      if (newPersonaIds.length > 0) {
        console.log(`Adding ${newPersonaIds.length} new personas to state`);

        setPersonaIds(prev => [...prev, ...newPersonaIds]);
        setPersonaDataById(prev => ({
          ...prev,
          ...newPersonaData
        }));

        // Select the first AI-generated persona
        if (newPersonaIds.length > 0) {
          const firstId = newPersonaIds[0];
          setSelectedPersonaId(firstId);
          setIsNewPersona(false);

          if (isNavigatingToPreview) {
            console.log("Automatically navigating to preview for Omi Recommended Persona");
            navigate(`/main/organization/workspace/research-objectives/${workspaceId}/${objectiveId}/persona-preview/${firstId}`);
            setIsNavigatingToPreview(false);
          }
        }

        // Mark this data as processed
        processedPersonaRef.current.add(dataSignature);
      } else {
        console.log("No new personas to add.");
        setIsNavigatingToPreview(false);
      }
    }
  }, [autoGeneratedData, savedPersonasFromAPI, isNavigatingToPreview, workspaceId, objectiveId, navigate]);

  // Clean up effect - reset processed personas when component unmounts
  useEffect(() => {
    return () => {
      processedPersonaRef.current.clear();
      hasInitializedRef.current = false;
    };
  }, []);

  const handleAddPersona = () => {
    const tempId = `temp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const newName = `Persona ${personaIds.length + 1}`;

    setPersonaIds(prev => [...prev, tempId]);
    setPersonaDataById(prev => ({
      ...prev,
      [tempId]: {
        name: newName,
        isAI: false,
        isAIGenerated: false,
        isSaved: false,
        id: tempId
      }
    }));
    setSelectedPersonaId(tempId);
    setIsNewPersona(true);
    trigger({
      stage: 'persona_builder',
      event: 'TRAIT_SELECTION_STARTED',
      payload: {},
    });
  };

  const handleSelectPersona = (id) => {
    const persona = personaDataById[id];
    const savedPersona = savedPersonasFromAPI?.find(p => p.id?.toString() === id?.toString());

    // Check if it's an AI persona by checking:
    // 1. Explicit flags in the persona object
    // 2. ID patterns (contains 'ai' or 'mock')
    // 3. Flags in the backend saved persona data
    const isAIType = !!(
      persona?.isAI ||
      persona?.isAIGenerated ||
      savedPersona?.auto_generated_persona ||
      id?.toString().toLowerCase().includes('ai') ||
      id?.toString().toLowerCase().includes('mock')
    );

    console.log("handleSelectPersona called:", { id, isAIType, personaName: persona?.name });

    if (isAIType) {
      handlePreviewPersona(id);
    } else {
      setSelectedPersonaId(id);
      setIsNewPersona(false);
    }
  };

  const handleAIGenerate = async () => {
    try {
      setIsMockGenerating(true); // Using this for loading state
      setIsNavigatingToPreview(true);

      // Trigger the real API call
      await generatePersonas();

      // Invalidate the persona list query to ensure the background data is fresh
      queryClient.invalidateQueries({
        queryKey: personaKeys.list(workspaceId, objectiveId)
      });

    } catch (error) {
      console.error("Failed to generate AI personas:", error);
      setIsNavigatingToPreview(false);
    } finally {
      setIsMockGenerating(false);
    }
  };

  const personas = useCallback(() =>
    personaIds.map(id => personaDataById[id]?.name || "Unnamed"),
    [personaIds, personaDataById]
  );

  const handleBack = useCallback(() => navigate(`/main/organization/workspace/research-objectives/${workspaceId}/${objectiveId}/research-mode`), [navigate, workspaceId, objectiveId]);

  const memoizedHandleAIGenerate = useCallback(handleAIGenerate, [personaIds, personaDataById, generatePersonas]);

  const handleItemClick = (category, item) => {
    // Disable editing for Omi personas
    const persona = personaDataById[selectedPersonaId];
    const isAIType = !!(
      persona?.isAI ||
      persona?.isAIGenerated ||
      selectedPersonaId?.toString().toLowerCase().includes('ai') ||
      selectedPersonaId?.toString().toLowerCase().includes('mock')
    );

    if (isAIType) {
      console.log("Editing disabled for Omi persona attributes");
      return;
    }

    if (editingItem && editingItem.item === item) {
      setEditingItem(null);
    } else {
      setEditingItem({ category, item });
    }
  };

  const handleSave = (selectedOption) => {
    if (!selectedPersonaId) return;

    console.log("DEBUG handleSave:", {
      item: editingItem.item,
      selectedOption,
      personaId: selectedPersonaId
    });

    setPersonaDataById(prevData => ({
      ...prevData,
      [selectedPersonaId]: {
        ...prevData[selectedPersonaId],
        [editingItem.item]: selectedOption,
      },
    }));

    if (!multiSelectAttributes.includes(editingItem.item)) {
      setEditingItem(null);
    }
  };

  const handleTabChange = async (tab) => {
    if (tab === "Persona" || tab === activeTab) {
      setIsTraitLoading(true);
      setActiveTab(tab);
      setEditingItem(null);
      setTimeout(() => setIsTraitLoading(false), 600);
      return;
    }

    setIsTraitLoading(true);
    setTimeout(() => setIsTraitLoading(false), 600);

    const currentData = personaDataById[selectedPersonaId] || {};
    const currentTraitGroup = traitGroupMapping[activeTab];

    // Check if it's an AI persona to skip validation
    const persona = personaDataById[selectedPersonaId];
    const isAIType = !!(
      persona?.isAI ||
      persona?.isAIGenerated ||
      selectedPersonaId?.toString().toLowerCase().includes('ai') ||
      selectedPersonaId?.toString().toLowerCase().includes('mock')
    );

    // Strict check for summary as per user requirement
    // Check explorationData.data.summary OR explorationData.summary
    const hasSummary = explorationData?.data?.summary || explorationData?.summary;

    // Debug log
    console.log("Validation Summary Check:", {
      hasSummary: !!hasSummary,
      summaryValue: hasSummary,
      activeTab,
      isAIType
    });

    // Only trigger validation if we have a research objective summary and NOT an AI persona
    if (!isAIType && hasSummary && currentTraitGroup && contentData[activeTab]) {
      const traitsToValidate = {};
      let hasTraitsToValidate = false;

      contentData[activeTab]?.items?.forEach(traitName => {
        if (currentData[traitName]) {
          const backendTraitName = traitNameMapping[traitName] || traitName.toLowerCase().replace(/ /g, '_');
          let value = currentData[traitName];

          switch (traitName) {
            case "Gender":
              value = value.toLowerCase();
              break;
            case "Geography":
              value = value.toLowerCase();
              break;
            case "Income":
              value = value.replace(/\$|\+/g, '').trim();
              break;
            default:
              break;
          }

          traitsToValidate[backendTraitName] = value;
          hasTraitsToValidate = true;
        }
      });

      if (hasTraitsToValidate) {
        try {
          const result = await validateTraits({
            objectiveId,
            traitGroup: currentTraitGroup,
            traits: traitsToValidate
          });

          if (!result.group_valid) {
            setValidationError({
              results: result.results,
              total_response: result.total_response,
              group: result.group,
              fromTab: activeTab,
              toTab: tab
            });
            {
              result.total_response && trigger({
                stage: 'persona_builder',
                event: 'TRAIT_VALIDATION_RESULT',
                payload: {
                  issue: [result.total_response]
                },
              });
            }
            setShowValidationModal(true);
            return;
          }
        } catch (error) {
          console.error(`Validation failed for ${currentTraitGroup}:`, error);
        }
      }
    }

    setActiveTab(tab);
    setEditingItem(null);
  };

  const handleValidationModalContinue = () => {
    if (validationError?.toTab) {
      setActiveTab(validationError.toTab);
    }
    setShowValidationModal(false);
    setValidationError(null);
    trigger({
      stage: 'persona_builder',
      event: 'TRAIT_SELECTION_STARTED',
      payload: {},
    });
  };

  const handleValidationModalClose = () => {
    setShowValidationModal(false);
    setValidationError(null);
    trigger({
      stage: 'persona_builder',
      event: 'TRAIT_SELECTION_STARTED',
      payload: {},
    });
  };

  const handleDoubleClick = (id) => {
    const persona = personaDataById[id];
    const isAIType = !!(
      persona?.isAI ||
      persona?.isAIGenerated ||
      id?.toString().toLowerCase().includes('ai') ||
      id?.toString().toLowerCase().includes('mock')
    );

    if (isAIType) {
      console.log("Renaming disabled for Omi personas");
      return;
    }

    setEditingPersonaId(id);
    setNewPersonaName(personaDataById[id]?.name || "");
  };

  const handleNameChange = (e) => {
    setNewPersonaName(e.target.value);
  };

  const handleNameBlur = () => {
    if (!editingPersonaId) return;

    if (newPersonaName.trim() === "") {
      setEditingPersonaId(null);
      return;
    }

    setPersonaDataById(prev => ({
      ...prev,
      [editingPersonaId]: {
        ...prev[editingPersonaId],
        name: newPersonaName.trim()
      }
    }));

    setEditingPersonaId(null);
  };

  const handleNameKeyDown = (e) => {
    if (e.key === 'Enter') {
      handleNameBlur();
    } else if (e.key === 'Escape') {
      setEditingPersonaId(null);
    }
  };

  const handleSubmit = async () => {
    if (!selectedPersonaId) return;

    trigger({
      stage: 'persona_builder',
      event: 'BACKSTORY_STARTED',
      payload: {},
    });

    const savedPersona = savedPersonasFromAPI?.find(p => p.id?.toString() === selectedPersonaId?.toString());
    const currentPersonaData = personaDataById[selectedPersonaId];

    const isAIType = !!(
      currentPersonaData?.isAI ||
      currentPersonaData?.isAIGenerated ||
      selectedPersonaId?.toString().toLowerCase().includes('ai') ||
      selectedPersonaId?.toString().toLowerCase().includes('mock')
    );

    if (isAIType) {
      // Skip backstory modal for AI personas and save directly
      console.log("Omi persona detected in handleSubmit, saving directly...");
      setBackstory(currentPersonaData?.backstory || "");
      handleBackstorySubmit();
      return;
    }

    if (!savedPersona || currentPersonaData?.isSaved === false) {
      // New persona - create
      setPendingAction('submit');
      setShowBackstoryPopup(true);
      setBackstory(currentPersonaData?.backstory || "");
    } else {
      // Existing persona - update
      setPendingAction('update');
      setBackstory(currentPersonaData?.backstory || "");
      handleBackstorySubmit();
    }
  };

  const handleDiscussionGuidelines = () => {
    if (isApproachLocked) {
      // If already decided, navigate directly to the appropriate next step
      const approach = exploration?.is_quantitative && !exploration?.is_qualitative ? 'quantitative' : 'qualitative'; // 'qualitative' covers both 'qualitative' and 'both' for navigation purposes in this project

      if (exploration?.is_quantitative && !exploration?.is_qualitative) {
        navigate(`/main/organization/workspace/research-objectives/${workspaceId}/${objectiveId}/population-builder`, {
          state: { researchApproach: 'quantitative' }
        });
      } else {
        // Qualitative or Both
        navigate(`/main/organization/workspace/research-objectives/${workspaceId}/${objectiveId}/depth-interview`, {
          state: { researchApproach: exploration?.is_qualitative && exploration?.is_quantitative ? 'both' : 'qualitative' }
        });
      }
      return;
    }
    setShowApproachModal(true);
  };

  const handleApproachSelect = async (approach) => {
    try {
      const methodData = {
        is_qualitative: approach === 'qualitative' || approach === 'both',
        is_quantitative: approach === 'quantitative' || approach === 'both'
      };

      await updateExplorationMethodMutation.mutateAsync({
        id: objectiveId,
        data: methodData
      });

      if (objectiveId) {
        localStorage.setItem(`approach_${objectiveId}`, approach.toLowerCase().trim());
      }

      if (approach === 'quantitative') {
        navigate(`/main/organization/workspace/research-objectives/${workspaceId}/${objectiveId}/population-builder`, {
          state: { researchApproach: approach }
        });
      } else {
        // Qualitative or Both
        navigate(`/main/organization/workspace/research-objectives/${workspaceId}/${objectiveId}/depth-interview`, {
          state: { researchApproach: approach }
        });
      }

      trigger({
        stage: 'persona_builder',
        event: 'RESEARCH_APPROACH_SELECTED',
        payload: { approach },
      });
    } catch (error) {
      console.error("Failed to update research approach:", error);
    }
  };

  const handleBackstorySubmit = async () => {
    const data = personaDataById[selectedPersonaId] || {};
    const isAIType = !!(
      data?.isAI ||
      data?.isAIGenerated ||
      selectedPersonaId?.toString().toLowerCase().includes('ai') ||
      selectedPersonaId?.toString().toLowerCase().includes('mock')
    );

    console.log("DEBUG handleBackstorySubmit - Current Data:", {
      selectedPersonaId,
      data,
      behavioralData: {
        "Decision Making Style": data["Decision Making Style"],
        "Purchase Frequency": data["Purchase Frequency"],
        "Purchase Channel": data["Purchase Channel"],
        "Price Sensitivity Profile": data["Price Sensitivity Profile"]
      }
    });

    const personaPayload = {
      name: data.name || selectedPersonaId,
      age_range: data.Age || "",
      gender: data.Gender || "",
      location_country: data.Geography || "",
      location_state: "",
      education_level: data["Education Level"] || "",
      occupation: data["Occupation / Employment Type"] || "",
      income_range: data["Income Level"] || "",
      family_size: data["Family Structure"] || "",  // Fixed key
      geography: data.Geography || "",
      lifestyle: data.Lifestyle || "",
      values: Array.isArray(data.Values) ? data.Values : (data.Values ? [data.Values] : []),
      personality: Array.isArray(data.Personality) ? data.Personality : (data.Personality ? [data.Personality] : []),
      interests: data.Interests || "",
      motivations: data.Motivations || "",

      // Fixed mappings based on data.js traitNameMapping
      // Compatibility: Sending both legacy and detailed keys to ensure backend/preview works
      brand_sensitivity: data["Brand Sensitivity"] || data["Brand sensitivity"] || "",
      brand_sensitivity_detailed: data["Brand Sensitivity"] || data["Brand sensitivity"] || "",

      price_sensitivity: data["Price Sensitivity"] || data["Price sensitivity"] || "",
      price_sensitivity_general: data["Price Sensitivity"] || data["Price sensitivity"] || "",

      decision_making_style: data["Decision Making Style"] || "", // Legacy
      decision_making_style_1: data["Decision Making Style"] || "",

      purchase_patterns: data["Purchase patterns"] || "",

      purchase_channel: data["Purchase Channel"] || data["Purchase channel"] || "", // Legacy
      purchase_channel_detailed: data["Purchase Channel"] || data["Purchase channel"] || "",

      mobility: data.Mobility || "",
      accommodation: data.Accommodation || data["Home Ownership"] || "", // Added Home Ownership
      marital_status: data["Marital Status"] || data["Marital status"] || "",
      daily_rhythm: data["Daily Rhythm"] || "",
      hobbies: data["Hobbies & Interests"] || "",
      professional_traits: data["Professional Traits"] || "",
      digital_activity: data["Digital Activity"] || "",
      preferences: data.Preferences || "",

      // Other Behavioral fields
      purchase_frequency: data["Purchase Frequency"] || "",
      price_sensitivity_profile: data["Price Sensitivity Profile"] || "",
      loyalty_behavior: data["Loyalty / Switching Behavior"] || "",
      purchase_triggers: data["Purchase Triggers & Occasions"] || "",
      purchase_barriers: data["Purchase Barriers"] || "",

      decision_making_style_2: data["Decision-Making Style"] || "",

      media_consumption: data["Media Consumption Patterns"] || "",

      digital_behavior: data["Digital Behavior"] || "", // Legacy
      digital_behavior_detailed: data["Digital Behavior"] || "",

      research_objective_id: "",
      exploration_id: objectiveId,
      backstory: backstory || data.backstory || "",
      sample_size: 50,
      auto_generated_persona: isAIType
    };

    console.log("DEBUG Payload being sent to backend:", {
      decision_making_style: personaPayload.decision_making_style,
      decision_making_style_1: personaPayload.decision_making_style_1,
      purchase_frequency: personaPayload.purchase_frequency,
      purchase_channel: personaPayload.purchase_channel,
      purchase_channel_detailed: personaPayload.purchase_channel_detailed,
      fullPayload: personaPayload
    });

    try {
      const savedPersona = savedPersonasFromAPI?.find(p => p.id === selectedPersonaId);
      const currentPersonaData = personaDataById[selectedPersonaId];

      if (!savedPersona || currentPersonaData?.isSaved === false) {
        // Create new persona
        trigger({
          stage: 'persona_builder',
          event: 'PERSONA_CREATION_STARTED',
          payload: {},
        });
        const result = await submitCompletePersona(personaPayload);

        if (result && result.data.id) {
          trigger({
            stage: 'persona_builder',
            event: 'CREATE_PERSONA',
            payload: {},
          });
        }

        if (result && result.id) {
          setPersonaDataById(prevData => ({
            ...prevData,
            [selectedPersonaId]: {
              ...prevData[selectedPersonaId],
              ...data,
              backstory: backstory || data.backstory,
              id: result.id, // Use the ID from the response
              isSaved: true
            },
          }));

          if (result.id !== selectedPersonaId) {
            setPersonaIds(prev => prev.map(id => id === selectedPersonaId ? result.id : id));
            setSelectedPersonaId(result.id);
          }
        }

        setShowBackstoryPopup(false);
        setBackstory("");

        // Reset the initialization flag to allow re-initialization
        hasInitializedRef.current = false;

        if (pendingAction === 'preview') {
          const finalPersonaId = result && result.id ? result.id : selectedPersonaId;
          navigate(`/main/organization/workspace/research-objectives/${workspaceId}/${objectiveId}/persona-preview/${finalPersonaId}`, {
            state: {
              personaId: finalPersonaId,
              personaName: data.name,
              personaData: { ...data, backstory }
            }
          });
        }
      } else {
        // Update existing persona
        trigger({
          stage: 'persona_builder',
          event: 'PERSONA_UPDATE_STARTED',
          payload: {},
        });

        // Update the payload with the saved persona ID
        personaPayload.id = selectedPersonaId;

        const result = await updatePersonaMutation.mutateAsync(personaPayload);

        if (result) {
          trigger({
            stage: 'persona_builder',
            event: 'PERSONA_UPDATED',
            payload: { personaId: selectedPersonaId },
          });

          // Update local state
          setPersonaDataById(prevData => ({
            ...prevData,
            [selectedPersonaId]: {
              ...prevData[selectedPersonaId],
              ...data,
              backstory: backstory || data.backstory,
              isSaved: true
            },
          }));

          setShowBackstoryPopup(false);
          setBackstory("");

          // Reset the initialization flag to allow re-fetch
          hasInitializedRef.current = false;

          if (pendingAction === 'preview') {
            navigate(`/main/organization/workspace/research-objectives/${workspaceId}/${objectiveId}/persona-preview/${selectedPersonaId}`);
          }
        }
      }
    } catch (error) {
      console.error(pendingAction === 'update' ? "Failed to update persona:" : "Failed to submit persona:", error);
    } finally {
      setPendingAction(null);
    }
  };

  const handlePreviewPersona = (id) => {
    console.log("handlePreviewPersona called with id:", id);

    // Find the persona in the saved list (use flexible comparison for IDs)
    const savedPersona = savedPersonasFromAPI?.find(p =>
      p.id?.toString() === id?.toString()
    );
    const personaData = personaDataById[id];

    console.log("Preview check:", { id, hasSavedPersona: !!savedPersona, isDataSaved: personaData?.isSaved });

    // If it's not saved or we don't have a backend ID
    if (!savedPersona || personaData?.isSaved === false) {
      const isAIType = !!(
        personaData?.isAI ||
        personaData?.isAIGenerated ||
        id?.toString().toLowerCase().includes('ai') ||
        id?.toString().toLowerCase().includes('mock')
      );

      setSelectedPersonaId(id);
      setPendingAction('preview');

      if (isAIType) {
        // Skip backstory modal for AI personas and save directly
        console.log("Omi persona detected in handlePreviewPersona, saving directly...");
        setBackstory(personaData?.backstory || "");
        handleBackstorySubmit();
      } else {
        setShowBackstoryPopup(true);
        setBackstory(personaData?.backstory || "");
      }
    } else {
      // It's saved, go directly to preview
      console.log("Navigating to preview for saved persona:", id);
      navigate(`/main/organization/workspace/research-objectives/${workspaceId}/${objectiveId}/persona-preview/${id}`);
    }
  };

  const currentPersonaData = personaDataById[selectedPersonaId] || {};

  // Check if any traits have been selected
  const hasSelectedTraits = Object.keys(optionData).some(trait => currentPersonaData[trait]);

  // Combine loading states
  const isProcessing = isSubmitting || isUpdating;

  return (
    <div className="p-4 md:p-8 relative min-h-[calc(100vh-100px)] flex flex-col">
      <div className="max-w-7xl mx-auto relative z-10 w-full flex-grow flex flex-col">
        <Header
          personas={personas()}
          onBack={handleBack}
          onAIGenerate={memoizedHandleAIGenerate}
          isGeneratingAI={isGeneratingPersonas}
          showAIGenerate={personaIds.length > 0}
        />

        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.1 }}
          className="bg-white/95 dark:bg-white/5 backdrop-blur-xl border-2 border-gray-200 dark:border-white/10 rounded-2xl shadow-2xl overflow-hidden p-6 md:p-8 min-h-[600px] relative z-10"
        >
          {personaIds.length > 0 && (
            <TabsNavigation
              tabs={tabs}
              activeTab={activeTab}
              onTabChange={handleTabChange}
            />
          )}

          {personaIds.length === 0 ? (
            <EmptyState
              onAddPersona={handleAddPersona}
              onAIGenerate={memoizedHandleAIGenerate}
              isGeneratingAI={isGeneratingPersonas || isMockGenerating}
            />
          ) : (
            <div className="flex flex-col lg:flex-row gap-8">
              {/* Sidebar: Persona List */}
              <div className="w-full lg:w-64 flex-shrink-0 space-y-4 bg-gray-50/50 dark:bg-black/10 p-4 rounded-2xl border border-gray-100 dark:border-white/5">
                <div className="space-y-2">
                  {personaIds.map(id => {
                    const persona = personaDataById[id];
                    if (!persona) return null;

                    return (
                      <PersonaListItem
                        key={id}
                        id={id}
                        name={persona.name}
                        isSelected={selectedPersonaId === id}
                        isEditing={editingPersonaId === id}
                        newName={newPersonaName}
                        isAIPersona={persona.isAI || persona.isAIGenerated}
                        isSaved={persona.isSaved}
                        savedPersona={savedPersonasFromAPI?.find(p => p.id === id)}
                        onSelect={() => handleSelectPersona(id)}
                        onDoubleClick={() => handleDoubleClick(id)}
                        onNameChange={handleNameChange}
                        onNameBlur={handleNameBlur}
                        onNameKeyDown={handleNameKeyDown}
                        onPreview={() => handlePreviewPersona(id)}
                        onEditClick={(e) => {
                          e.stopPropagation();
                          handleDoubleClick(id);
                        }}
                      />
                    );
                  })}
                </div>

                <button
                  onClick={handleAddPersona}
                  className={`w-full flex items-center justify-center gap-2 p-3 rounded-xl border-2 border-dashed transition-all font-medium ${personaIds.length === 0
                    ? "bg-blue-600 border-blue-600 text-white hover:bg-blue-700 shadow-lg shadow-blue-500/20"
                    : "border-gray-300 dark:border-white/10 text-gray-500 dark:text-gray-400 hover:border-blue-500 dark:hover:border-blue-500/50 hover:text-blue-600 dark:hover:text-blue-400"
                    }`}
                >
                  <TbPlus size={20} />
                  <span>{personaIds.length === 0 ? "Create Your First Persona" : "Add Persona"}</span>
                </button>
              </div>

              {/* Content Wrapper */}
              <div className="flex-grow flex flex-col gap-6">
                {/* Content Area */}
                <div className="flex-grow flex flex-col md:flex-row gap-8 bg-gray-50/80 dark:bg-black/10 p-6 rounded-2xl border border-gray-100 dark:border-white/5 h-full relative min-h-[500px]">
                  {isTraitLoading ? (
                    <div className="absolute inset-0 flex flex-col items-center justify-center z-50 bg-gray-50/50 dark:bg-black/20 backdrop-blur-sm rounded-2xl">
                      <TbLoader className="animate-spin text-blue-600 dark:text-blue-400 mb-4" size={48} />
                      <p className="text-sm font-medium text-gray-500 dark:text-gray-400 animate-pulse">Loading attributes...</p>
                    </div>
                  ) : (
                    <>
                      {activeTab !== 'Persona' && (
                        <div className={`w-full flex-shrink-0 space-y-3 transition-all duration-300 ${editingItem ? "md:w-64" : "md:w-[440px]"}`}>
                          <h3 className="text-lg font-bold text-gray-900 dark:text-white mb-4">Attributes</h3>
                          <AnimatePresence mode="wait">
                            <motion.div
                              key={activeTab}
                              initial={{ opacity: 0, x: 20 }}
                              animate={{ opacity: 1, x: 0 }}
                              exit={{ opacity: 0, x: -20 }}
                              className={`grid gap-3 transition-all duration-300 ${editingItem ? "grid-cols-1" : "grid-cols-2"}`}
                            >
                              {contentData[activeTab]?.items?.map(item => {
                                const isAIPersona = !!(
                                  currentPersonaData?.isAI ||
                                  currentPersonaData?.isAIGenerated ||
                                  selectedPersonaId?.toString().toLowerCase().includes('ai') ||
                                  selectedPersonaId?.toString().toLowerCase().includes('mock')
                                );

                                return (
                                  <AttributeItem
                                    key={item}
                                    item={item}
                                    currentValue={currentPersonaData[item]}
                                    isEditing={editingItem?.item === item}
                                    onClick={() => handleItemClick(activeTab, item)}
                                    disabled={isAIPersona}
                                  />
                                );
                              })}
                            </motion.div>
                          </AnimatePresence>
                        </div>
                      )}

                      <SelectionPanel
                        editingItem={editingItem}
                        currentValue={currentPersonaData[editingItem?.item]}
                        onSelect={handleSave}
                      />

                      {!editingItem && activeTab !== 'Persona' && (
                        <div className="flex-grow flex items-center justify-center p-12 text-center text-gray-500 dark:text-gray-400 bg-gray-50/50 dark:bg-white/5 rounded-2xl border border-dashed border-gray-200 dark:border-white/10">
                          <div>
                            <TbEdit size={48} className="mx-auto mb-4 opacity-20" />
                            <p>Select an attribute on the left to configure it.</p>
                          </div>
                        </div>
                      )}
                    </>
                  )}
                </div>

                {/* Submit Button */}
                <div className="flex gap-2 justify-end">
                  {/* Submit Button - Hidden for AI Personas */}
                  {!currentPersonaData?.isAI && !currentPersonaData?.isAIGenerated && (
                    <button
                      onClick={handleSubmit}
                      disabled={isProcessing || !hasSelectedTraits}
                      className="flex items-center gap-2 px-10 py-3 bg-gradient-to-r from-blue-600 to-blue-700 text-white rounded-xl font-bold shadow-lg shadow-blue-500/30 hover:shadow-blue-500/40 hover:scale-105 transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      {isProcessing
                        ? 'Processing...'
                        : currentPersonaData.isSaved
                          ? 'Update'
                          : 'Submit'
                      }
                    </button>
                  )}

                  {/* Conditionally render Discussion Guidelines button */}
                  {savedPersonasFromAPI.length > 0 && (
                    <button
                      onClick={handleDiscussionGuidelines}
                      disabled={updateExplorationMethodMutation.isPending}
                      className="flex items-center gap- px-10 py-3 bg-gradient-to-r from-blue-600 to-blue-700 text-white rounded-xl font-bold shadow-lg shadow-blue-500/30 hover:shadow-blue-500/40 hover:scale-105 transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      {updateExplorationMethodMutation.isPending ? 'Processing...' : 'Next step'}
                    </button>
                  )}
                </div>
              </div>
            </div>
          )}
        </motion.div>
      </div>

      <BackstoryModal
        show={showBackstoryPopup}
        selectedPersona={currentPersonaData.name || selectedPersonaId}
        backstory={backstory}
        isSubmitting={isProcessing} // Use combined processing state
        onBackstoryChange={(e) => setBackstory(e.target.value)}
        onSubmit={handleBackstorySubmit}
        onClose={() => setShowBackstoryPopup(false)}
      />

      <ValidationModal
        show={showValidationModal}
        validationError={validationError}
        onContinue={handleValidationModalContinue}
        onClose={handleValidationModalClose}
      />

      <ApproachSelectionModal
        isOpen={showApproachModal}
        onClose={() => setShowApproachModal(false)}
        onSelect={handleApproachSelect}
        isLoading={updateExplorationMethodMutation.isPending}
        currentApproach={currentApproach}
        isLocked={isApproachLocked}
      />

      <style dangerouslySetInnerHTML={{
        __html: `
        .scrollbar-none::-webkit-scrollbar { display: none; }
        .scrollbar-none { -ms-overflow-style: none; scrollbar-width: none; }
      `}} />
    </div>
  );
};

export default PersonaBuilder;